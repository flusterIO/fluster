use std::collections::BTreeMap;

use crate::core::{
    models::taggable::taggable_model::Taggable, types::enums::taggable_type::TaggableTypeEnum,
};
use gray_matter::Pod;
use serde::{Deserialize, Serialize};
use specta::Type;

// type BtreeValueArray = Vec<BTreeMap<&'static str, Value>>;

/// This model mirrors the structure of the front matter as it appears in a user's note, where the
/// nested entities represent the data as it is stored in the database. This model should handle
/// all parsing and saving of all nested models.
#[derive(Debug, Default, Clone, Serialize, Type, Deserialize)]
pub struct FrontMatter {
    pub id: Option<String>,
    /// The user_provided_id is the id field as it appears in the user's note.  The id field in
    /// this struct is generated by Surreal.
    pub user_provided_id: Option<String>,
    pub title: String,
    pub summary: Option<String>,
    pub tags: Vec<Taggable>,
    pub subject: Option<Taggable>,
    pub topic: Option<Taggable>,
}

impl FrontMatter {
    pub fn from_gray_matter(pod: Option<Pod>) -> FrontMatter {
        let mut tags: Vec<Taggable> = Vec::new();
        match pod {
            None => FrontMatter::default(),
            Some(p) => {
                let mut x = FrontMatter::default();
                // Set title
                let data = p.as_hashmap();
                if let Err(_) = p.as_hashmap() {
                    FrontMatter::default()
                } else {
                    let d = data.unwrap();
                    if d.contains_key("title") {
                        let title = d["title"].as_string();
                        if title.is_ok() {
                            x.title = title.unwrap();
                        }
                    }
                    // Set summary
                    if d.contains_key("summary") {
                        let summary = d["summary"].as_string();
                        if summary.is_ok() {
                            x.summary = Some(summary.unwrap());
                        }
                    }
                    // Set tags
                    if d.contains_key("tags") {
                        let mut item_tags = d["tags"].clone();
                        for _ in 0..item_tags.len() {
                            let tag_item = item_tags.pop().as_string();
                            if let Ok(item) = tag_item {
                                tags.push(Taggable {
                                    value: item,
                                    id: None,
                                    tag_type: TaggableTypeEnum::Tag,
                                });
                            }
                        }
                    }
                    // Set subject
                    if d.contains_key("subject") {
                        let item_subject = d["subject"].clone();
                        x.subject = Some(Taggable {
                            id: None,
                            value: item_subject.as_string().unwrap(),
                            tag_type: TaggableTypeEnum::Subject,
                        });
                    }
                    // Set topic
                    if d.contains_key("topic") {
                        let item_topic = d["topic"].clone();
                        x.topic = Some(Taggable {
                            id: None,
                            value: item_topic.as_string().unwrap(),
                            tag_type: TaggableTypeEnum::Topic,
                        });
                    }
                    // Set note_id
                    if d.contains_key("id") {
                        let note_id = d["id"].as_string();
                        if note_id.is_ok() {
                            x.user_provided_id = Some(note_id.unwrap());
                        }
                    }
                    x
                }
            }
        }
    }
}
