use std::collections::BTreeMap;

use crate::core::{
    models::taggable::taggable_model::Taggable, types::enums::taggable_type::TaggableTypeEnum,
};
use gray_matter::Pod;
use serde::{Deserialize, Serialize};
use specta::Type;
use surrealdb::sql::Value;

type BtreeValueArray = Vec<BTreeMap<&'static str, Value>>;

// FIX: Clean this up and remove this file. There's no need to nest the front_matter data if we're not using diesel anymore.

/// This model mirrors the structure of the front matter as it appears in a user's note, where the
/// nested entities represent the data as it is stored in the database. This model should handle
/// all parsing and saving of all nested models.
#[derive(Debug, Default, Clone, Serialize, Type, Deserialize)]
pub struct FrontMatter {
    pub id: Option<String>,
    /// The user_provided_id is the id field as it appears in the user's note.  The id field in
    /// this struct is generated by Surreal.
    pub user_provided_id: Option<String>,
    pub title: String,
    pub summary: Option<String>,
    pub tags: Vec<Taggable>,
    pub subject: Option<Taggable>,
    pub topic: Option<Taggable>,
}

impl FrontMatter {
    // pub fn to_btree_map(&self) -> BTreeMap<&'static str, Value> {
    //     let mut m = self.data.to_btree_map();
    //     m.insert("tags", self.tags.iter().map(|x| x.fmt));
    //     let topics: BtreeValueArray = Vec::new();
    //     let subjects: BtreeValueArray = Vec::new();
    //     m
    // }
    pub fn from_gray_matter(pod: Option<Pod>) -> FrontMatter {
        let mut tags: Vec<Taggable> = Vec::new();
        let mut subjects: Vec<Taggable> = Vec::new();
        let mut topics: Vec<Taggable> = Vec::new();
        let front_matter: FrontMatter = match pod {
            None => FrontMatter::default(),
            Some(p) => {
                let mut x = FrontMatter::default();
                // Set title
                let data = p.as_hashmap();
                if let Err(_) = p.as_hashmap() {
                    FrontMatter::default()
                } else {
                    let d = data.unwrap();
                    if d.contains_key("title") {
                        let title = d["title"].as_string();
                        if title.is_ok() {
                            x.title = title.unwrap();
                        }
                    }
                    // Set summary
                    if d.contains_key("summary") {
                        let summary = d["summary"].as_string();
                        if summary.is_ok() {
                            x.summary = Some(summary.unwrap());
                        }
                    }
                    // Set tags
                    if d.contains_key("tags") {
                        let mut item_tags = d["tags"].clone();
                        for _ in 0..item_tags.len() {
                            let tag_item = item_tags.pop().as_string();
                            if let Ok(item) = tag_item {
                                tags.push(Taggable {
                                    value: item,
                                    id: None,
                                    tag_type: TaggableTypeEnum::Tag,
                                });
                            }
                        }
                    }

                    if d.contains_key("subject") {
                        // let mut item_tags = d["subjects"].clone();
                        // for _ in 0..item_tags.len() {
                        //     let tag_item = item_tags.pop().as_string();
                        //     if let Ok(item) = tag_item {
                        //         subjects.push(TagCreatable {
                        //             value: item,
                        //             id: None,
                        //             tag_type: TaggableTypeEnum::Subject.to_string(),
                        //         });
                        //     }
                        // }
                    }
                    if d.contains_key("topic") {
                        let mut item_tags = d["topics"].clone();
                        for _ in 0..item_tags.len() {
                            let tag_item = item_tags.pop().as_string();
                            if let Ok(item) = tag_item {
                                topics.push(Taggable {
                                    value: item,
                                    id: None,
                                    tag_type: TaggableTypeEnum::Topic,
                                });
                            }
                        }
                    }
                    // Set note_id
                    if d.contains_key("id") {
                        let note_id = d["id"].as_string();
                        if note_id.is_ok() {
                            x.user_provided_id = Some(note_id.unwrap());
                        }
                    }
                    // x.tags = tags.unwrap().;
                    x
                }
            }
        };
        FrontMatter {
            data: front_matter,
            tags,
            topics,
            subjects,
        }
    }
}
