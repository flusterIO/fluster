// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::actions::front_matter::get_many::*;
use crate::api::actions::mdx_note::get_many::*;
use crate::api::data_interface::database::utils::*;
use crate::api::embedded_ts::*;
use crate::api::global_actions::parse_directory::sync_fs_directory::sync_methods::sync_mdx_notes::*;
use crate::api::models::bibliography::bib_entry::*;
use crate::api::models::bibliography::bib_file::*;
use crate::api::models::front_matter::front_matter_model::*;
use crate::api::models::mdx_note::mdx_note_group::mdx_note_group::*;
use crate::api::models::mdx_note::mdx_note_summary::*;
use crate::api::models::taggable::taggable::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1256856087;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__embedded_ts__EmbeddedTypescriptFiles_get_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EmbeddedTypescriptFiles_get",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::embedded_ts::EmbeddedTypescriptFiles::get(&api_file_path),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_atime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_get_atime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.atime.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_ctime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_get_ctime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.ctime.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_file_path_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_get_file_path",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.file_path.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_id_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_get_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_mtime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_get_mtime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.mtime.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_raw_body_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_get_raw_body",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.raw_body.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_atime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_set_atime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            let api_atime = <Option<chrono::NaiveDateTime>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.atime = api_atime;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_ctime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_set_ctime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            let api_ctime = <Option<chrono::NaiveDateTime>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.ctime = api_ctime;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_file_path_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_set_file_path",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            let api_file_path = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.file_path = api_file_path;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_id_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_set_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.id = api_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_mtime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_set_mtime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            let api_mtime = <Option<chrono::NaiveDateTime>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.mtime = api_mtime;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_raw_body_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MdxNoteSummary_auto_accessor_set_raw_body",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
            >>::sse_decode(&mut deserializer);
            let api_raw_body = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.raw_body = api_raw_body;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__bibliography__bib_file__bibtex_file_from_filesystem_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "bibtex_file_from_filesystem_path", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_fspath = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, FlusterError>((move || async move {
                         let output_ok = crate::api::models::bibliography::bib_file::BibtexFile::from_filesystem_path(&api_fspath).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__models__bibliography__bib_file__bibtex_file_from_raw_file_content_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "bibtex_file_from_raw_file_content", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_content = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, FlusterError>((move || async move {
                         let output_ok = crate::api::models::bibliography::bib_file::BibtexFile::from_raw_file_content(&api_file_content).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__models__bibliography__bib_file__bibtex_file_save_entries_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bibtex_file_save_entries",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::models::bibliography::bib_file::BibtexFile>::sse_decode(
                &mut deserializer,
            );
            let api_db = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::models::bibliography::bib_file::BibtexFile::save_entries(
                                &api_that,
                                &*api_db_guard,
                            )
                            .await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__models__params__cross_language_file_object__cross_language_file_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "cross_language_file_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::params::cross_language_file_object::CrossLanguageFile::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__models__front_matter__front_matter_model__front_matter_from_gray_matter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "front_matter_from_gray_matter", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pod = <Option<Pod>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::front_matter::front_matter_model::FrontMatter::from_gray_matter(api_pod))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__utils__file_system__fs_utils__get_app_config_dir_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_app_config_dir",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, FlusterError>((move || {
                let output_ok = crate::api::utils::file_system::fs_utils::get_app_config_dir()?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__utils__file_system__fs_utils__get_app_data_dir_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_app_data_dir",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, FlusterError>((move || {
                let output_ok = crate::api::utils::file_system::fs_utils::get_app_data_dir()?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__data_interface__database__utils__get_database_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_database_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::data_interface::database::utils::get_database_path(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__data_interface__get_database_status__get_database_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_database_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::data_interface::get_database_status::get_database_status()
                                .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__actions__front_matter__get_many__get_front_matter_entities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_front_matter_entities",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::actions::front_matter::get_many::get_front_matter_entities(
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__actions__mdx_note__get_many__get_mdx_note_summaries_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_mdx_note_summaries",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::actions::mdx_note::get_many::get_mdx_note_summaries().await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__models__taggable__taggable__get_tag_regular_expression_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_tag_regular_expression",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::taggable::taggable::get_tag_regular_expression(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__search__get_text_similarity__get_text_similarity_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_text_similarity",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_a = <String>::sse_decode(&mut deserializer);
            let api_b = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::utils::search::get_text_similarity::get_text_similarity(
                        api_a, api_b,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__enums__setting_page_ids__keymap_section_id_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keymap_section_id_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::enums::setting_page_ids::KeymapSectionId::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__params__sync_mdx_typescript_params__math_label_option_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "math_label_option_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__models__mdx_note__mdx_note_group__mdx_note_group__mdx_note_group_from_file_system_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "mdx_note_group_from_file_system_path", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup::from_file_system_path(api_file_path))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__models__mdx_note__mdx_note_group__mdx_note_group__mdx_note_group_from_file_system_path_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "mdx_note_group_from_file_system_path_async", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup::from_file_system_path_async(api_file_path).await)?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__models__mdx_note__mdx_note_group__mdx_note_group__mdx_note_group_from_raw_mdx_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "mdx_note_group_from_raw_mdx_string", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_raw_file_content = <String>::sse_decode(&mut deserializer);
let api_file_path = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup::from_raw_mdx_string(api_raw_file_content, api_file_path))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__models__enums__parsable_file_extension__note_type_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "note_type_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::enums::parsable_file_extension::NoteType::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__initialize__on_desktop_init__on_desktop_init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "on_desktop_init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::initialize::on_desktop_init::on_desktop_init();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__file_system__fs_utils__path_exists_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "path_exists",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::utils::file_system::fs_utils::path_exists(&api_file_path),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__settings__setting_page_id__setting_page_id_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "setting_page_id_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::settings::setting_page_id::SettingPageId::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__global_actions__get_summary_list__summary_list_query__summary_list_query_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "summary_list_query_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__global_actions__get_summary_list__summary_list_result__summary_list_results_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "summary_list_results_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__models__enums__supported_language__supported_syntax_language_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "supported_syntax_language_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::models::enums::supported_language::SupportedSyntaxLanguage::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__global_actions__parse_directory__sync_fs_directory__sync_filesystem_directory__sync_directory_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sync_directory", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_opts = <crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                         let output_ok = Result::<_,()>::Ok(crate::api::global_actions::parse_directory::sync_fs_directory::sync_filesystem_directory::sync_directory(api_opts).await)?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__global_actions__parse_directory__sync_fs_directory__models__sync_filesystem_options__sync_filesystem_directory_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sync_filesystem_directory_options_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__global_actions__parse_directory__sync_fs_directory__sync_methods__sync_mdx_notes__sync_mdx_filesystem_notes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sync_mdx_filesystem_notes", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_notes_path = <String>::sse_decode(&mut deserializer);
let api_error_sender = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < FlusterError >>>>::sse_decode(&mut deserializer);
let api_c = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, FlusterError>((move || async move {
                        let mut api_error_sender_guard = None;
let mut api_c_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_error_sender, 0, false), flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_c, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_error_sender_guard = Some(api_error_sender.lockable_decode_async_ref().await),
1 => api_c_guard = Some(api_c.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let api_error_sender_guard = api_error_sender_guard.unwrap();
let mut api_c_guard = api_c_guard.unwrap();
 let output_ok = crate::api::global_actions::parse_directory::sync_fs_directory::sync_methods::sync_mdx_notes::sync_mdx_filesystem_notes(&api_notes_path, &*api_error_sender_guard, &mut *api_c_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__global_actions__parse_directory__sync_fs_directory__sync_methods__sync_user_bibliography__sync_user_bibliography_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sync_user_bibliography", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_bib_path = <String>::sse_decode(&mut deserializer);
let api_error_sender = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < FlusterError >>>>::sse_decode(&mut deserializer);
let api_db = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>>::sse_decode(&mut deserializer);
let api_n_threads = <u32>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_error_sender_guard = None;
let mut api_db_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_error_sender, 0, false), flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_db, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_error_sender_guard = Some(api_error_sender.lockable_decode_async_ref().await),
1 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_error_sender_guard = api_error_sender_guard.unwrap();
let api_db_guard = api_db_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::global_actions::parse_directory::sync_fs_directory::sync_methods::sync_user_bibliography::sync_user_bibliography(&api_bib_path, &*api_error_sender_guard, &*api_db_guard, api_n_threads).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__models__taggable__taggable__taggable_from_mdx_content_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "taggable_from_mdx_content",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_data_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_data, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_data_guard = Some(api_data.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_data_guard = api_data_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::taggable::taggable::Taggable::from_mdx_content(
                            &*api_data_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__taggable__taggable__taggable_from_pod_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "taggable_from_pod_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_data_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_data, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_data_guard = Some(api_data.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_data_guard = api_data_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::taggable::taggable::Taggable::from_pod_data(
                            &*api_data_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedFile>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<Vec<FrontMatterEntity>>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<Vec<MdxNoteEntity>>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<FlusterError>>
);

// Section: dart2rust

impl SseDecode for BibEntryEntity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EmbeddedFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedFile>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EmbeddedTypescriptFiles {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FlusterError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FlusterResult<MdxNoteGroup> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FlusterResult<Vec<FrontMatterEntity>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<FrontMatterEntity>>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FlusterResult<Vec<MdxNoteEntity>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<MdxNoteEntity>>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MdxNoteSummary {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PathBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Pod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Regex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for chrono::NaiveDateTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i64>::sse_decode(deserializer);
        return chrono::DateTime::from_timestamp_micros(inner)
            .expect("invalid or out-of-range datetime")
            .naive_utc();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedFile>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            FlusterResult<Vec<FrontMatterEntity>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<Vec<MdxNoteEntity>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<FlusterError>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::models::bibliography::bib_file::BibtexFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <Option<String>>::sse_decode(deserializer);
        let mut var_entries = <Vec<BibEntryEntity>>::sse_decode(deserializer);
        return crate::api::models::bibliography::bib_file::BibtexFile {
            path: var_path,
            entries: var_entries,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::models::params::cross_language_file_object::CrossLanguageFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <String>::sse_decode(deserializer);
        let mut var_noteType =
            <crate::api::models::enums::parsable_file_extension::NoteType>::sse_decode(
                deserializer,
            );
        return crate::api::models::params::cross_language_file_object::CrossLanguageFile {
            path: var_path,
            note_type: var_noteType,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::data_interface::get_database_status::FlusterDatabaseStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::data_interface::get_database_status::FlusterDatabaseStatus::NotInitialized,
1 => crate::api::data_interface::get_database_status::FlusterDatabaseStatus::ErrorEncountered,
2 => crate::api::data_interface::get_database_status::FlusterDatabaseStatus::NotConnected,
3 => crate::api::data_interface::get_database_status::FlusterDatabaseStatus::Connected,
4 => crate::api::data_interface::get_database_status::FlusterDatabaseStatus::AwaitingInitialPing,
            _ => unreachable!("Invalid variant for FlusterDatabaseStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::api::models::front_matter::front_matter_model::FrontMatter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data =
            <crate::api::models::front_matter::front_matter_entity::FrontMatterEntity>::sse_decode(
                deserializer,
            );
        let mut var_tags =
            <Vec<crate::api::models::taggable::tag_model::TagCreatable>>::sse_decode(deserializer);
        let mut var_subjects =
            <Vec<crate::api::models::taggable::tag_model::TagCreatable>>::sse_decode(deserializer);
        let mut var_topics =
            <Vec<crate::api::models::taggable::tag_model::TagCreatable>>::sse_decode(deserializer);
        return crate::api::models::front_matter::front_matter_model::FrontMatter {
            data: var_data,
            tags: var_tags,
            subjects: var_subjects,
            topics: var_topics,
        };
    }
}

impl SseDecode for crate::api::models::front_matter::front_matter_entity::FrontMatterEntity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_summary = <Option<String>>::sse_decode(deserializer);
        let mut var_mdxNoteId = <i32>::sse_decode(deserializer);
        let mut var_userProvidedId = <Option<String>>::sse_decode(deserializer);
        return crate::api::models::front_matter::front_matter_entity::FrontMatterEntity {
            id: var_id,
            title: var_title,
            summary: var_summary,
            mdx_note_id: var_mdxNoteId,
            user_provided_id: var_userProvidedId,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::models::enums::setting_page_ids::KeymapSectionId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::models::enums::setting_page_ids::KeymapSectionId::Navigation,
            1 => crate::api::models::enums::setting_page_ids::KeymapSectionId::UiAndLayout,
            _ => unreachable!("Invalid variant for KeymapSectionId: {}", inner),
        };
    }
}

impl SseDecode for Vec<BibEntryEntity> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<BibEntryEntity>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FlusterError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FlusterError>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<MdxNoteSummary> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<MdxNoteSummary>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::models::taggable::tag_model::TagCreatable> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::models::taggable::tag_model::TagCreatable>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::models::taggable::taggable::Taggable> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::models::taggable::taggable::Taggable>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::models::params::sync_mdx_typescript_params::MathLabelOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::Ams,
            1 => crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::All,
            2 => crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::None,
            _ => unreachable!("Invalid variant for MathLabelOption: {}", inner),
        };
    }
}

impl SseDecode for crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <Option<i32>>::sse_decode(deserializer);
        let mut var_filePath = <Option<String>>::sse_decode(deserializer);
        let mut var_rawBody = <String>::sse_decode(deserializer);
        let mut var_ctime = <Option<chrono::NaiveDateTime>>::sse_decode(deserializer);
        let mut var_mtime = <Option<chrono::NaiveDateTime>>::sse_decode(deserializer);
        let mut var_atime = <Option<chrono::NaiveDateTime>>::sse_decode(deserializer);
        return crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable {
            id: var_id,
            file_path: var_filePath,
            raw_body: var_rawBody,
            ctime: var_ctime,
            mtime: var_mtime,
            atime: var_atime,
        };
    }
}

impl SseDecode for crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mdx =
            <crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable>::sse_decode(
                deserializer,
            );
        let mut var_frontMatter =
            <crate::api::models::front_matter::front_matter_model::FrontMatter>::sse_decode(
                deserializer,
            );
        let mut var_tags =
            <Vec<crate::api::models::taggable::taggable::Taggable>>::sse_decode(deserializer);
        return crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup {
            mdx: var_mdx,
            front_matter: var_frontMatter,
            tags: var_tags,
        };
    }
}

impl SseDecode for crate::api::models::enums::parsable_file_extension::NoteType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::models::enums::parsable_file_extension::NoteType::Mdx,
            1 => crate::api::models::enums::parsable_file_extension::NoteType::Markdown,
            _ => unreachable!("Invalid variant for NoteType: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<EmbeddedFile> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<EmbeddedFile>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<PathBuf> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<PathBuf>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Pod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Pod>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<chrono::NaiveDateTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<chrono::NaiveDateTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<FlusterError>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<FlusterError>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::models::settings::setting_page_id::SettingPageId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::models::settings::setting_page_id::SettingPageId::General,
            1 => crate::api::models::settings::setting_page_id::SettingPageId::WebInterface,
            2 => crate::api::models::settings::setting_page_id::SettingPageId::Ui,
            3 => crate::api::models::settings::setting_page_id::SettingPageId::KeyMap,
            4 => crate::api::models::settings::setting_page_id::SettingPageId::Ai,
            5 => {
                crate::api::models::settings::setting_page_id::SettingPageId::SearchAndAutoSettings
            }
            6 => crate::api::models::settings::setting_page_id::SettingPageId::SyncAndDatabase,
            _ => unreachable!("Invalid variant for SettingPageId: {}", inner),
        };
    }
}

impl SseDecode
    for crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mdxPerPage = <u16>::sse_decode(deserializer);
        let mut var_mdxPage = <u16>::sse_decode(deserializer);
        return crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery{mdx_per_page: var_mdxPerPage, mdx_page: var_mdxPage};
    }
}

impl SseDecode
    for crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mdxNotes = <Vec<MdxNoteSummary>>::sse_decode(deserializer);
        return crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults{mdx_notes: var_mdxNotes};
    }
}

impl SseDecode for crate::api::models::enums::supported_language::SupportedSyntaxLanguage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Abap,
1 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Actionscript3,
2 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ada,
3 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::AngularHtml,
4 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::AngularTs,
5 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Apache,
6 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Apex,
7 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Apl,
8 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Applescript,
9 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ara,
10 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Asciidoc,
11 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Asm,
12 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Astro,
13 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Awk,
14 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ballerina,
15 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bat,
16 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Beancount,
17 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Berry,
18 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bibtex,
19 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bicep,
20 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Blade,
21 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bsl,
22 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::C,
23 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cadence,
24 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cairo,
25 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Clarity,
26 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Clojure,
27 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cmake,
28 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cobol,
29 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Codeowners,
30 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Codeql,
31 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Coffee,
32 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::CommonLisp,
33 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Coq,
34 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cpp,
35 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Crystal,
36 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Csharp,
37 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Css,
38 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Csv,
39 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cue,
40 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cypher,
41 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::D,
42 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dart,
43 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dax,
44 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Desktop,
45 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Diff,
46 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Docker,
47 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dotenv,
48 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::DreamMaker,
49 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Edge,
50 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Elixir,
51 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Elm,
52 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::EmacsLisp,
53 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Erb,
54 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Erlang,
55 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fennel,
56 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fish,
57 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fluent,
58 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::FortranFixedForm,
59 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::FortranFreeForm,
60 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fsharp,
61 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gdresource,
62 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gdscript,
63 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gdshader,
64 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Genie,
65 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gherkin,
66 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GitCommit,
67 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GitRebase,
68 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gleam,
69 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GlimmerJs,
70 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GlimmerTs,
71 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Glsl,
72 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gnuplot,
73 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Go,
74 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Graphql,
75 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Groovy,
76 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hack,
77 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Haml,
78 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Handlebars,
79 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Haskell,
80 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Haxe,
81 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hcl,
82 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hjson,
83 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hlsl,
84 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Html,
85 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::HtmlDerivative,
86 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Http,
87 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hxml,
88 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hy,
89 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Imba,
90 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ini,
91 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Java,
92 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Javascript,
93 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jinja,
94 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jison,
95 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Json,
96 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Json5,
97 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsonc,
98 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsonl,
99 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsonnet,
100 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jssm,
101 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsx,
102 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Julia,
103 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kotlin,
104 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kusto,
105 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Latex,
106 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lean,
107 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Less,
108 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Liquid,
109 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Llvm,
110 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Log,
111 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Logo,
112 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lua,
113 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Luau,
114 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Make,
115 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Markdown,
116 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Marko,
117 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Matlab,
118 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mdc,
119 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mdx,
120 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mermaid,
121 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mipsasm,
122 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mojo,
123 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Move,
124 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Narrat,
125 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nextflow,
126 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nginx,
127 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nim,
128 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nix,
129 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nushell,
130 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::ObjectiveC,
131 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::ObjectiveCpp,
132 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ocaml,
133 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Pascal,
134 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Perl,
135 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Php,
136 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Plsql,
137 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Po,
138 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Polar,
139 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Postcss,
140 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Powerquery,
141 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Powershell,
142 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Prisma,
143 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Prolog,
144 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Proto,
145 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Pug,
146 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Puppet,
147 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Purescript,
148 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Python,
149 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Qml,
150 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Qmldir,
151 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Qss,
152 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::R,
153 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Racket,
154 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Raku,
155 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Razor,
156 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Reg,
157 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Regexp,
158 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rel,
159 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Riscv,
160 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rst,
161 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ruby,
162 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rust,
163 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sas,
164 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sass,
165 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Scala,
166 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Scheme,
167 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Scss,
168 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sdbl,
169 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shaderlab,
170 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shellscript,
171 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shellsession,
172 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Smalltalk,
173 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Solidity,
174 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Soy,
175 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sparql,
176 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Splunk,
177 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sql,
178 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::SshConfig,
179 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Stata,
180 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Stylus,
181 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Svelte,
182 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Swift,
183 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::SystemVerilog,
184 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Systemd,
185 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Talonscript,
186 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tasl,
187 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tcl,
188 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Templ,
189 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Terraform,
190 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tex,
191 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Toml,
192 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::TsTags,
193 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tsv,
194 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tsx,
195 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Turtle,
196 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Twig,
197 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typescript,
198 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typespec,
199 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typst,
200 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::V,
201 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vala,
202 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vb,
203 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Verilog,
204 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vhdl,
205 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Viml,
206 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vue,
207 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::VueHtml,
208 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vyper,
209 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wasm,
210 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wenyan,
211 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wgsl,
212 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wikitext,
213 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wit,
214 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wolfram,
215 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Xml,
216 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Xsl,
217 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Yaml,
218 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Zenscript,
219 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Zig,
220 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Adoc,
221 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Batch,
222 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Be,
223 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::OneC,
224 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cdc,
225 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Clj,
226 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ql,
227 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Coffeescript,
228 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lisp,
229 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::CPlusPlus,
230 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::CSharp,
231 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cs,
232 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cql,
233 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dockerfile,
234 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Elisp,
235 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Erl,
236 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ftl,
237 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F,
238 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::For,
239 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F77,
240 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F90,
241 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F95,
242 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F03,
243 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F08,
244 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F18,
245 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::FSharp,
246 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fs,
247 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gjs,
248 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gts,
249 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gql,
250 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hbs,
251 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hs,
252 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Properties,
253 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Js,
254 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fsl,
255 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jl,
256 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kt,
257 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kts,
258 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kql,
259 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lean4,
260 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Makefile,
261 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Md,
262 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mmd,
263 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mips,
264 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nar,
265 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nf,
266 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nu,
267 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Objc,
268 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Pot,
269 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Potx,
270 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ps,
271 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ps1,
272 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Protobuf,
273 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jade,
274 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Py,
275 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Perl6,
276 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Regex,
277 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rb,
278 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rs,
279 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::OneCQuery,
280 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shader,
281 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bash,
282 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sh,
283 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shell,
284 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Zsh,
285 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Console,
286 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::ClosureTemplates,
287 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Spl,
288 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Styl,
289 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Talon,
290 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tf,
291 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tfvars,
292 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lit,
293 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ts,
294 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tsp,
295 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typ,
296 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cmd,
297 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vim,
298 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vimscript,
299 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vy,
300 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mediawiki,
301 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wiki,
302 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wl,
303 => crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Yml,
            _ => unreachable!("Invalid variant for SupportedSyntaxLanguage: {}", inner),
        };
    }
}

impl SseDecode for crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_dirPath = <String>::sse_decode(deserializer);
let mut var_bibPath = <Option<String>>::sse_decode(deserializer);
let mut var_nThreads = <u32>::sse_decode(deserializer);
return crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions{dir_path: var_dirPath, bib_path: var_bibPath, n_threads: var_nThreads};}
                }

impl SseDecode for crate::api::models::taggable::tag_model::TagCreatable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <Option<i32>>::sse_decode(deserializer);
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_tagType = <String>::sse_decode(deserializer);
        return crate::api::models::taggable::tag_model::TagCreatable {
            id: var_id,
            value: var_value,
            tag_type: var_tagType,
        };
    }
}

impl SseDecode for crate::api::models::taggable::taggable::TagFromContentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tags =
            <Vec<crate::api::models::taggable::taggable::Taggable>>::sse_decode(deserializer);
        let mut var_parsedContent = <String>::sse_decode(deserializer);
        return crate::api::models::taggable::taggable::TagFromContentResult {
            tags: var_tags,
            parsed_content: var_parsedContent,
        };
    }
}

impl SseDecode for crate::api::models::taggable::taggable::Taggable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_tagType =
            <crate::api::models::enums::taggable_type::TaggableTypeEnum>::sse_decode(deserializer);
        return crate::api::models::taggable::taggable::Taggable {
            value: var_value,
            tag_type: var_tagType,
        };
    }
}

impl SseDecode for crate::api::models::enums::taggable_type::TaggableTypeEnum {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::models::enums::taggable_type::TaggableTypeEnum::Tag,
            1 => crate::api::models::enums::taggable_type::TaggableTypeEnum::Topic,
            2 => crate::api::models::enums::taggable_type::TaggableTypeEnum::Subject,
            _ => unreachable!("Invalid variant for TaggableTypeEnum: {}", inner),
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        1 => wire__crate__api__embedded_ts__EmbeddedTypescriptFiles_get_impl(port, ptr, rust_vec_len, data_len),
14 => wire__crate__api__models__bibliography__bib_file__bibtex_file_from_filesystem_path_impl(port, ptr, rust_vec_len, data_len),
15 => wire__crate__api__models__bibliography__bib_file__bibtex_file_from_raw_file_content_impl(port, ptr, rust_vec_len, data_len),
16 => wire__crate__api__models__bibliography__bib_file__bibtex_file_save_entries_impl(port, ptr, rust_vec_len, data_len),
17 => wire__crate__api__models__params__cross_language_file_object__cross_language_file_default_impl(port, ptr, rust_vec_len, data_len),
18 => wire__crate__api__models__front_matter__front_matter_model__front_matter_from_gray_matter_impl(port, ptr, rust_vec_len, data_len),
21 => wire__crate__api__data_interface__database__utils__get_database_path_impl(port, ptr, rust_vec_len, data_len),
22 => wire__crate__api__data_interface__get_database_status__get_database_status_impl(port, ptr, rust_vec_len, data_len),
23 => wire__crate__api__actions__front_matter__get_many__get_front_matter_entities_impl(port, ptr, rust_vec_len, data_len),
24 => wire__crate__api__actions__mdx_note__get_many__get_mdx_note_summaries_impl(port, ptr, rust_vec_len, data_len),
25 => wire__crate__api__models__taggable__taggable__get_tag_regular_expression_impl(port, ptr, rust_vec_len, data_len),
27 => wire__crate__api__models__enums__setting_page_ids__keymap_section_id_default_impl(port, ptr, rust_vec_len, data_len),
28 => wire__crate__api__models__params__sync_mdx_typescript_params__math_label_option_default_impl(port, ptr, rust_vec_len, data_len),
29 => wire__crate__api__models__mdx_note__mdx_note_group__mdx_note_group__mdx_note_group_from_file_system_path_impl(port, ptr, rust_vec_len, data_len),
30 => wire__crate__api__models__mdx_note__mdx_note_group__mdx_note_group__mdx_note_group_from_file_system_path_async_impl(port, ptr, rust_vec_len, data_len),
31 => wire__crate__api__models__mdx_note__mdx_note_group__mdx_note_group__mdx_note_group_from_raw_mdx_string_impl(port, ptr, rust_vec_len, data_len),
32 => wire__crate__api__models__enums__parsable_file_extension__note_type_default_impl(port, ptr, rust_vec_len, data_len),
33 => wire__crate__api__initialize__on_desktop_init__on_desktop_init_impl(port, ptr, rust_vec_len, data_len),
35 => wire__crate__api__models__settings__setting_page_id__setting_page_id_default_impl(port, ptr, rust_vec_len, data_len),
36 => wire__crate__api__global_actions__get_summary_list__summary_list_query__summary_list_query_default_impl(port, ptr, rust_vec_len, data_len),
37 => wire__crate__api__global_actions__get_summary_list__summary_list_result__summary_list_results_default_impl(port, ptr, rust_vec_len, data_len),
38 => wire__crate__api__models__enums__supported_language__supported_syntax_language_default_impl(port, ptr, rust_vec_len, data_len),
39 => wire__crate__api__global_actions__parse_directory__sync_fs_directory__sync_filesystem_directory__sync_directory_impl(port, ptr, rust_vec_len, data_len),
40 => wire__crate__api__global_actions__parse_directory__sync_fs_directory__models__sync_filesystem_options__sync_filesystem_directory_options_default_impl(port, ptr, rust_vec_len, data_len),
41 => wire__crate__api__global_actions__parse_directory__sync_fs_directory__sync_methods__sync_mdx_notes__sync_mdx_filesystem_notes_impl(port, ptr, rust_vec_len, data_len),
42 => wire__crate__api__global_actions__parse_directory__sync_fs_directory__sync_methods__sync_user_bibliography__sync_user_bibliography_impl(port, ptr, rust_vec_len, data_len),
43 => wire__crate__api__models__taggable__taggable__taggable_from_mdx_content_impl(port, ptr, rust_vec_len, data_len),
44 => wire__crate__api__models__taggable__taggable__taggable_from_pod_data_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        2 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_atime_impl(ptr, rust_vec_len, data_len),
3 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_ctime_impl(ptr, rust_vec_len, data_len),
4 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_file_path_impl(ptr, rust_vec_len, data_len),
5 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_id_impl(ptr, rust_vec_len, data_len),
6 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_mtime_impl(ptr, rust_vec_len, data_len),
7 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_get_raw_body_impl(ptr, rust_vec_len, data_len),
8 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_atime_impl(ptr, rust_vec_len, data_len),
9 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_ctime_impl(ptr, rust_vec_len, data_len),
10 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_file_path_impl(ptr, rust_vec_len, data_len),
11 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_id_impl(ptr, rust_vec_len, data_len),
12 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_mtime_impl(ptr, rust_vec_len, data_len),
13 => wire__crate__api__models__mdx_note__mdx_note_summary__MdxNoteSummary_auto_accessor_set_raw_body_impl(ptr, rust_vec_len, data_len),
19 => wire__crate__api__utils__file_system__fs_utils__get_app_config_dir_impl(ptr, rust_vec_len, data_len),
20 => wire__crate__api__utils__file_system__fs_utils__get_app_data_dir_impl(ptr, rust_vec_len, data_len),
26 => wire__crate__api__utils__search__get_text_similarity__get_text_similarity_impl(ptr, rust_vec_len, data_len),
34 => wire__crate__api__utils__file_system__fs_utils__path_exists_impl(ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BibEntryEntity> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BibEntryEntity> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BibEntryEntity>> for BibEntryEntity {
    fn into_into_dart(self) -> FrbWrapper<BibEntryEntity> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EmbeddedFile> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EmbeddedFile> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EmbeddedFile>> for EmbeddedFile {
    fn into_into_dart(self) -> FrbWrapper<EmbeddedFile> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EmbeddedTypescriptFiles> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<EmbeddedTypescriptFiles>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EmbeddedTypescriptFiles>>
    for EmbeddedTypescriptFiles
{
    fn into_into_dart(self) -> FrbWrapper<EmbeddedTypescriptFiles> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FlusterError> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FlusterError> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FlusterError>> for FlusterError {
    fn into_into_dart(self) -> FrbWrapper<FlusterError> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FlusterResult<MdxNoteGroup>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FlusterResult<MdxNoteGroup>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FlusterResult<MdxNoteGroup>>>
    for FlusterResult<MdxNoteGroup>
{
    fn into_into_dart(self) -> FrbWrapper<FlusterResult<MdxNoteGroup>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FlusterResult<Vec<FrontMatterEntity>>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FlusterResult<Vec<FrontMatterEntity>>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FlusterResult<Vec<FrontMatterEntity>>>>
    for FlusterResult<Vec<FrontMatterEntity>>
{
    fn into_into_dart(self) -> FrbWrapper<FlusterResult<Vec<FrontMatterEntity>>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FlusterResult<Vec<MdxNoteEntity>>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FlusterResult<Vec<MdxNoteEntity>>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FlusterResult<Vec<MdxNoteEntity>>>>
    for FlusterResult<Vec<MdxNoteEntity>>
{
    fn into_into_dart(self) -> FrbWrapper<FlusterResult<Vec<MdxNoteEntity>>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MdxNoteSummary> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MdxNoteSummary> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MdxNoteSummary>> for MdxNoteSummary {
    fn into_into_dart(self) -> FrbWrapper<MdxNoteSummary> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PathBuf> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PathBuf> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PathBuf>> for PathBuf {
    fn into_into_dart(self) -> FrbWrapper<PathBuf> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Pod> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Pod> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Pod>> for Pod {
    fn into_into_dart(self) -> FrbWrapper<Pod> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Regex> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Regex> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Regex>> for Regex {
    fn into_into_dart(self) -> FrbWrapper<Regex> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::bibliography::bib_file::BibtexFile {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.path.into_into_dart().into_dart(),
            self.entries.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::bibliography::bib_file::BibtexFile
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::bibliography::bib_file::BibtexFile>
    for crate::api::models::bibliography::bib_file::BibtexFile
{
    fn into_into_dart(self) -> crate::api::models::bibliography::bib_file::BibtexFile {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::params::cross_language_file_object::CrossLanguageFile
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.path.into_into_dart().into_dart(),
            self.note_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::params::cross_language_file_object::CrossLanguageFile
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::params::cross_language_file_object::CrossLanguageFile,
    > for crate::api::models::params::cross_language_file_object::CrossLanguageFile
{
    fn into_into_dart(
        self,
    ) -> crate::api::models::params::cross_language_file_object::CrossLanguageFile {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::data_interface::get_database_status::FlusterDatabaseStatus
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::NotInitialized => 0.into_dart(),
            Self::ErrorEncountered => 1.into_dart(),
            Self::NotConnected => 2.into_dart(),
            Self::Connected => 3.into_dart(),
            Self::AwaitingInitialPing => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::data_interface::get_database_status::FlusterDatabaseStatus
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::data_interface::get_database_status::FlusterDatabaseStatus,
    > for crate::api::data_interface::get_database_status::FlusterDatabaseStatus
{
    fn into_into_dart(
        self,
    ) -> crate::api::data_interface::get_database_status::FlusterDatabaseStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::front_matter::front_matter_model::FrontMatter
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.data.into_into_dart().into_dart(),
            self.tags.into_into_dart().into_dart(),
            self.subjects.into_into_dart().into_dart(),
            self.topics.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::front_matter::front_matter_model::FrontMatter
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::front_matter::front_matter_model::FrontMatter,
    > for crate::api::models::front_matter::front_matter_model::FrontMatter
{
    fn into_into_dart(self) -> crate::api::models::front_matter::front_matter_model::FrontMatter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::front_matter::front_matter_entity::FrontMatterEntity
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.summary.into_into_dart().into_dart(),
            self.mdx_note_id.into_into_dart().into_dart(),
            self.user_provided_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::front_matter::front_matter_entity::FrontMatterEntity
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::front_matter::front_matter_entity::FrontMatterEntity,
    > for crate::api::models::front_matter::front_matter_entity::FrontMatterEntity
{
    fn into_into_dart(
        self,
    ) -> crate::api::models::front_matter::front_matter_entity::FrontMatterEntity {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::enums::setting_page_ids::KeymapSectionId
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Navigation => 0.into_dart(),
            Self::UiAndLayout => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::enums::setting_page_ids::KeymapSectionId
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::enums::setting_page_ids::KeymapSectionId>
    for crate::api::models::enums::setting_page_ids::KeymapSectionId
{
    fn into_into_dart(self) -> crate::api::models::enums::setting_page_ids::KeymapSectionId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::params::sync_mdx_typescript_params::MathLabelOption
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ams => 0.into_dart(),
            Self::All => 1.into_dart(),
            Self::None => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::params::sync_mdx_typescript_params::MathLabelOption
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::params::sync_mdx_typescript_params::MathLabelOption,
    > for crate::api::models::params::sync_mdx_typescript_params::MathLabelOption
{
    fn into_into_dart(
        self,
    ) -> crate::api::models::params::sync_mdx_typescript_params::MathLabelOption {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.file_path.into_into_dart().into_dart(),
            self.raw_body.into_into_dart().into_dart(),
            self.ctime.into_into_dart().into_dart(),
            self.mtime.into_into_dart().into_dart(),
            self.atime.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable,
    > for crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable
{
    fn into_into_dart(self) -> crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.mdx.into_into_dart().into_dart(),
            self.front_matter.into_into_dart().into_dart(),
            self.tags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup,
    > for crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup
{
    fn into_into_dart(
        self,
    ) -> crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::enums::parsable_file_extension::NoteType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Mdx => 0.into_dart(),
            Self::Markdown => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::enums::parsable_file_extension::NoteType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::enums::parsable_file_extension::NoteType>
    for crate::api::models::enums::parsable_file_extension::NoteType
{
    fn into_into_dart(self) -> crate::api::models::enums::parsable_file_extension::NoteType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::settings::setting_page_id::SettingPageId
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::General => 0.into_dart(),
            Self::WebInterface => 1.into_dart(),
            Self::Ui => 2.into_dart(),
            Self::KeyMap => 3.into_dart(),
            Self::Ai => 4.into_dart(),
            Self::SearchAndAutoSettings => 5.into_dart(),
            Self::SyncAndDatabase => 6.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::settings::setting_page_id::SettingPageId
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::settings::setting_page_id::SettingPageId>
    for crate::api::models::settings::setting_page_id::SettingPageId
{
    fn into_into_dart(self) -> crate::api::models::settings::setting_page_id::SettingPageId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.mdx_per_page.into_into_dart().into_dart(),
            self.mdx_page.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery,
    > for crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery
{
    fn into_into_dart(
        self,
    ) -> crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.mdx_notes.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults,
    > for crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults
{
    fn into_into_dart(
        self,
    ) -> crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::enums::supported_language::SupportedSyntaxLanguage
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Abap => 0.into_dart(),
            Self::Actionscript3 => 1.into_dart(),
            Self::Ada => 2.into_dart(),
            Self::AngularHtml => 3.into_dart(),
            Self::AngularTs => 4.into_dart(),
            Self::Apache => 5.into_dart(),
            Self::Apex => 6.into_dart(),
            Self::Apl => 7.into_dart(),
            Self::Applescript => 8.into_dart(),
            Self::Ara => 9.into_dart(),
            Self::Asciidoc => 10.into_dart(),
            Self::Asm => 11.into_dart(),
            Self::Astro => 12.into_dart(),
            Self::Awk => 13.into_dart(),
            Self::Ballerina => 14.into_dart(),
            Self::Bat => 15.into_dart(),
            Self::Beancount => 16.into_dart(),
            Self::Berry => 17.into_dart(),
            Self::Bibtex => 18.into_dart(),
            Self::Bicep => 19.into_dart(),
            Self::Blade => 20.into_dart(),
            Self::Bsl => 21.into_dart(),
            Self::C => 22.into_dart(),
            Self::Cadence => 23.into_dart(),
            Self::Cairo => 24.into_dart(),
            Self::Clarity => 25.into_dart(),
            Self::Clojure => 26.into_dart(),
            Self::Cmake => 27.into_dart(),
            Self::Cobol => 28.into_dart(),
            Self::Codeowners => 29.into_dart(),
            Self::Codeql => 30.into_dart(),
            Self::Coffee => 31.into_dart(),
            Self::CommonLisp => 32.into_dart(),
            Self::Coq => 33.into_dart(),
            Self::Cpp => 34.into_dart(),
            Self::Crystal => 35.into_dart(),
            Self::Csharp => 36.into_dart(),
            Self::Css => 37.into_dart(),
            Self::Csv => 38.into_dart(),
            Self::Cue => 39.into_dart(),
            Self::Cypher => 40.into_dart(),
            Self::D => 41.into_dart(),
            Self::Dart => 42.into_dart(),
            Self::Dax => 43.into_dart(),
            Self::Desktop => 44.into_dart(),
            Self::Diff => 45.into_dart(),
            Self::Docker => 46.into_dart(),
            Self::Dotenv => 47.into_dart(),
            Self::DreamMaker => 48.into_dart(),
            Self::Edge => 49.into_dart(),
            Self::Elixir => 50.into_dart(),
            Self::Elm => 51.into_dart(),
            Self::EmacsLisp => 52.into_dart(),
            Self::Erb => 53.into_dart(),
            Self::Erlang => 54.into_dart(),
            Self::Fennel => 55.into_dart(),
            Self::Fish => 56.into_dart(),
            Self::Fluent => 57.into_dart(),
            Self::FortranFixedForm => 58.into_dart(),
            Self::FortranFreeForm => 59.into_dart(),
            Self::Fsharp => 60.into_dart(),
            Self::Gdresource => 61.into_dart(),
            Self::Gdscript => 62.into_dart(),
            Self::Gdshader => 63.into_dart(),
            Self::Genie => 64.into_dart(),
            Self::Gherkin => 65.into_dart(),
            Self::GitCommit => 66.into_dart(),
            Self::GitRebase => 67.into_dart(),
            Self::Gleam => 68.into_dart(),
            Self::GlimmerJs => 69.into_dart(),
            Self::GlimmerTs => 70.into_dart(),
            Self::Glsl => 71.into_dart(),
            Self::Gnuplot => 72.into_dart(),
            Self::Go => 73.into_dart(),
            Self::Graphql => 74.into_dart(),
            Self::Groovy => 75.into_dart(),
            Self::Hack => 76.into_dart(),
            Self::Haml => 77.into_dart(),
            Self::Handlebars => 78.into_dart(),
            Self::Haskell => 79.into_dart(),
            Self::Haxe => 80.into_dart(),
            Self::Hcl => 81.into_dart(),
            Self::Hjson => 82.into_dart(),
            Self::Hlsl => 83.into_dart(),
            Self::Html => 84.into_dart(),
            Self::HtmlDerivative => 85.into_dart(),
            Self::Http => 86.into_dart(),
            Self::Hxml => 87.into_dart(),
            Self::Hy => 88.into_dart(),
            Self::Imba => 89.into_dart(),
            Self::Ini => 90.into_dart(),
            Self::Java => 91.into_dart(),
            Self::Javascript => 92.into_dart(),
            Self::Jinja => 93.into_dart(),
            Self::Jison => 94.into_dart(),
            Self::Json => 95.into_dart(),
            Self::Json5 => 96.into_dart(),
            Self::Jsonc => 97.into_dart(),
            Self::Jsonl => 98.into_dart(),
            Self::Jsonnet => 99.into_dart(),
            Self::Jssm => 100.into_dart(),
            Self::Jsx => 101.into_dart(),
            Self::Julia => 102.into_dart(),
            Self::Kotlin => 103.into_dart(),
            Self::Kusto => 104.into_dart(),
            Self::Latex => 105.into_dart(),
            Self::Lean => 106.into_dart(),
            Self::Less => 107.into_dart(),
            Self::Liquid => 108.into_dart(),
            Self::Llvm => 109.into_dart(),
            Self::Log => 110.into_dart(),
            Self::Logo => 111.into_dart(),
            Self::Lua => 112.into_dart(),
            Self::Luau => 113.into_dart(),
            Self::Make => 114.into_dart(),
            Self::Markdown => 115.into_dart(),
            Self::Marko => 116.into_dart(),
            Self::Matlab => 117.into_dart(),
            Self::Mdc => 118.into_dart(),
            Self::Mdx => 119.into_dart(),
            Self::Mermaid => 120.into_dart(),
            Self::Mipsasm => 121.into_dart(),
            Self::Mojo => 122.into_dart(),
            Self::Move => 123.into_dart(),
            Self::Narrat => 124.into_dart(),
            Self::Nextflow => 125.into_dart(),
            Self::Nginx => 126.into_dart(),
            Self::Nim => 127.into_dart(),
            Self::Nix => 128.into_dart(),
            Self::Nushell => 129.into_dart(),
            Self::ObjectiveC => 130.into_dart(),
            Self::ObjectiveCpp => 131.into_dart(),
            Self::Ocaml => 132.into_dart(),
            Self::Pascal => 133.into_dart(),
            Self::Perl => 134.into_dart(),
            Self::Php => 135.into_dart(),
            Self::Plsql => 136.into_dart(),
            Self::Po => 137.into_dart(),
            Self::Polar => 138.into_dart(),
            Self::Postcss => 139.into_dart(),
            Self::Powerquery => 140.into_dart(),
            Self::Powershell => 141.into_dart(),
            Self::Prisma => 142.into_dart(),
            Self::Prolog => 143.into_dart(),
            Self::Proto => 144.into_dart(),
            Self::Pug => 145.into_dart(),
            Self::Puppet => 146.into_dart(),
            Self::Purescript => 147.into_dart(),
            Self::Python => 148.into_dart(),
            Self::Qml => 149.into_dart(),
            Self::Qmldir => 150.into_dart(),
            Self::Qss => 151.into_dart(),
            Self::R => 152.into_dart(),
            Self::Racket => 153.into_dart(),
            Self::Raku => 154.into_dart(),
            Self::Razor => 155.into_dart(),
            Self::Reg => 156.into_dart(),
            Self::Regexp => 157.into_dart(),
            Self::Rel => 158.into_dart(),
            Self::Riscv => 159.into_dart(),
            Self::Rst => 160.into_dart(),
            Self::Ruby => 161.into_dart(),
            Self::Rust => 162.into_dart(),
            Self::Sas => 163.into_dart(),
            Self::Sass => 164.into_dart(),
            Self::Scala => 165.into_dart(),
            Self::Scheme => 166.into_dart(),
            Self::Scss => 167.into_dart(),
            Self::Sdbl => 168.into_dart(),
            Self::Shaderlab => 169.into_dart(),
            Self::Shellscript => 170.into_dart(),
            Self::Shellsession => 171.into_dart(),
            Self::Smalltalk => 172.into_dart(),
            Self::Solidity => 173.into_dart(),
            Self::Soy => 174.into_dart(),
            Self::Sparql => 175.into_dart(),
            Self::Splunk => 176.into_dart(),
            Self::Sql => 177.into_dart(),
            Self::SshConfig => 178.into_dart(),
            Self::Stata => 179.into_dart(),
            Self::Stylus => 180.into_dart(),
            Self::Svelte => 181.into_dart(),
            Self::Swift => 182.into_dart(),
            Self::SystemVerilog => 183.into_dart(),
            Self::Systemd => 184.into_dart(),
            Self::Talonscript => 185.into_dart(),
            Self::Tasl => 186.into_dart(),
            Self::Tcl => 187.into_dart(),
            Self::Templ => 188.into_dart(),
            Self::Terraform => 189.into_dart(),
            Self::Tex => 190.into_dart(),
            Self::Toml => 191.into_dart(),
            Self::TsTags => 192.into_dart(),
            Self::Tsv => 193.into_dart(),
            Self::Tsx => 194.into_dart(),
            Self::Turtle => 195.into_dart(),
            Self::Twig => 196.into_dart(),
            Self::Typescript => 197.into_dart(),
            Self::Typespec => 198.into_dart(),
            Self::Typst => 199.into_dart(),
            Self::V => 200.into_dart(),
            Self::Vala => 201.into_dart(),
            Self::Vb => 202.into_dart(),
            Self::Verilog => 203.into_dart(),
            Self::Vhdl => 204.into_dart(),
            Self::Viml => 205.into_dart(),
            Self::Vue => 206.into_dart(),
            Self::VueHtml => 207.into_dart(),
            Self::Vyper => 208.into_dart(),
            Self::Wasm => 209.into_dart(),
            Self::Wenyan => 210.into_dart(),
            Self::Wgsl => 211.into_dart(),
            Self::Wikitext => 212.into_dart(),
            Self::Wit => 213.into_dart(),
            Self::Wolfram => 214.into_dart(),
            Self::Xml => 215.into_dart(),
            Self::Xsl => 216.into_dart(),
            Self::Yaml => 217.into_dart(),
            Self::Zenscript => 218.into_dart(),
            Self::Zig => 219.into_dart(),
            Self::Adoc => 220.into_dart(),
            Self::Batch => 221.into_dart(),
            Self::Be => 222.into_dart(),
            Self::OneC => 223.into_dart(),
            Self::Cdc => 224.into_dart(),
            Self::Clj => 225.into_dart(),
            Self::Ql => 226.into_dart(),
            Self::Coffeescript => 227.into_dart(),
            Self::Lisp => 228.into_dart(),
            Self::CPlusPlus => 229.into_dart(),
            Self::CSharp => 230.into_dart(),
            Self::Cs => 231.into_dart(),
            Self::Cql => 232.into_dart(),
            Self::Dockerfile => 233.into_dart(),
            Self::Elisp => 234.into_dart(),
            Self::Erl => 235.into_dart(),
            Self::Ftl => 236.into_dart(),
            Self::F => 237.into_dart(),
            Self::For => 238.into_dart(),
            Self::F77 => 239.into_dart(),
            Self::F90 => 240.into_dart(),
            Self::F95 => 241.into_dart(),
            Self::F03 => 242.into_dart(),
            Self::F08 => 243.into_dart(),
            Self::F18 => 244.into_dart(),
            Self::FSharp => 245.into_dart(),
            Self::Fs => 246.into_dart(),
            Self::Gjs => 247.into_dart(),
            Self::Gts => 248.into_dart(),
            Self::Gql => 249.into_dart(),
            Self::Hbs => 250.into_dart(),
            Self::Hs => 251.into_dart(),
            Self::Properties => 252.into_dart(),
            Self::Js => 253.into_dart(),
            Self::Fsl => 254.into_dart(),
            Self::Jl => 255.into_dart(),
            Self::Kt => 256.into_dart(),
            Self::Kts => 257.into_dart(),
            Self::Kql => 258.into_dart(),
            Self::Lean4 => 259.into_dart(),
            Self::Makefile => 260.into_dart(),
            Self::Md => 261.into_dart(),
            Self::Mmd => 262.into_dart(),
            Self::Mips => 263.into_dart(),
            Self::Nar => 264.into_dart(),
            Self::Nf => 265.into_dart(),
            Self::Nu => 266.into_dart(),
            Self::Objc => 267.into_dart(),
            Self::Pot => 268.into_dart(),
            Self::Potx => 269.into_dart(),
            Self::Ps => 270.into_dart(),
            Self::Ps1 => 271.into_dart(),
            Self::Protobuf => 272.into_dart(),
            Self::Jade => 273.into_dart(),
            Self::Py => 274.into_dart(),
            Self::Perl6 => 275.into_dart(),
            Self::Regex => 276.into_dart(),
            Self::Rb => 277.into_dart(),
            Self::Rs => 278.into_dart(),
            Self::OneCQuery => 279.into_dart(),
            Self::Shader => 280.into_dart(),
            Self::Bash => 281.into_dart(),
            Self::Sh => 282.into_dart(),
            Self::Shell => 283.into_dart(),
            Self::Zsh => 284.into_dart(),
            Self::Console => 285.into_dart(),
            Self::ClosureTemplates => 286.into_dart(),
            Self::Spl => 287.into_dart(),
            Self::Styl => 288.into_dart(),
            Self::Talon => 289.into_dart(),
            Self::Tf => 290.into_dart(),
            Self::Tfvars => 291.into_dart(),
            Self::Lit => 292.into_dart(),
            Self::Ts => 293.into_dart(),
            Self::Tsp => 294.into_dart(),
            Self::Typ => 295.into_dart(),
            Self::Cmd => 296.into_dart(),
            Self::Vim => 297.into_dart(),
            Self::Vimscript => 298.into_dart(),
            Self::Vy => 299.into_dart(),
            Self::Mediawiki => 300.into_dart(),
            Self::Wiki => 301.into_dart(),
            Self::Wl => 302.into_dart(),
            Self::Yml => 303.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::enums::supported_language::SupportedSyntaxLanguage
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::models::enums::supported_language::SupportedSyntaxLanguage,
    > for crate::api::models::enums::supported_language::SupportedSyntaxLanguage
{
    fn into_into_dart(
        self,
    ) -> crate::api::models::enums::supported_language::SupportedSyntaxLanguage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    [
                    self.dir_path.into_into_dart().into_dart(),
self.bib_path.into_into_dart().into_dart(),
self.n_threads.into_into_dart().into_dart()
                ].into_dart()
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions> for crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions {
            fn into_into_dart(self) -> crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::taggable::tag_model::TagCreatable {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.tag_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::taggable::tag_model::TagCreatable
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::taggable::tag_model::TagCreatable>
    for crate::api::models::taggable::tag_model::TagCreatable
{
    fn into_into_dart(self) -> crate::api::models::taggable::tag_model::TagCreatable {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::models::taggable::taggable::TagFromContentResult
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tags.into_into_dart().into_dart(),
            self.parsed_content.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::taggable::taggable::TagFromContentResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::taggable::taggable::TagFromContentResult>
    for crate::api::models::taggable::taggable::TagFromContentResult
{
    fn into_into_dart(self) -> crate::api::models::taggable::taggable::TagFromContentResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::taggable::taggable::Taggable {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.tag_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::taggable::taggable::Taggable
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::taggable::taggable::Taggable>
    for crate::api::models::taggable::taggable::Taggable
{
    fn into_into_dart(self) -> crate::api::models::taggable::taggable::Taggable {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::enums::taggable_type::TaggableTypeEnum {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Tag => 0.into_dart(),
            Self::Topic => 1.into_dart(),
            Self::Subject => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::enums::taggable_type::TaggableTypeEnum
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::enums::taggable_type::TaggableTypeEnum>
    for crate::api::models::enums::taggable_type::TaggableTypeEnum
{
    fn into_into_dart(self) -> crate::api::models::enums::taggable_type::TaggableTypeEnum {
        self
    }
}

impl SseEncode for BibEntryEntity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EmbeddedFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< EmbeddedFile>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EmbeddedTypescriptFiles {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FlusterError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FlusterResult<MdxNoteGroup> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FlusterResult<Vec<FrontMatterEntity>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<FrontMatterEntity>>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FlusterResult<Vec<MdxNoteEntity>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<MdxNoteEntity>>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MdxNoteSummary {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for PathBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Pod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Regex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for chrono::NaiveDateTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.and_utc().timestamp_micros(), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedFile>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            FlusterResult<Vec<FrontMatterEntity>>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<Vec<MdxNoteEntity>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<FlusterError>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::models::bibliography::bib_file::BibtexFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.path, serializer);
        <Vec<BibEntryEntity>>::sse_encode(self.entries, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::models::params::cross_language_file_object::CrossLanguageFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path, serializer);
        <crate::api::models::enums::parsable_file_extension::NoteType>::sse_encode(
            self.note_type,
            serializer,
        );
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::data_interface::get_database_status::FlusterDatabaseStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::api::data_interface::get_database_status::FlusterDatabaseStatus::NotInitialized => { 0 }
crate::api::data_interface::get_database_status::FlusterDatabaseStatus::ErrorEncountered => { 1 }
crate::api::data_interface::get_database_status::FlusterDatabaseStatus::NotConnected => { 2 }
crate::api::data_interface::get_database_status::FlusterDatabaseStatus::Connected => { 3 }
crate::api::data_interface::get_database_status::FlusterDatabaseStatus::AwaitingInitialPing => { 4 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::models::front_matter::front_matter_model::FrontMatter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::models::front_matter::front_matter_entity::FrontMatterEntity>::sse_encode(
            self.data, serializer,
        );
        <Vec<crate::api::models::taggable::tag_model::TagCreatable>>::sse_encode(
            self.tags, serializer,
        );
        <Vec<crate::api::models::taggable::tag_model::TagCreatable>>::sse_encode(
            self.subjects,
            serializer,
        );
        <Vec<crate::api::models::taggable::tag_model::TagCreatable>>::sse_encode(
            self.topics,
            serializer,
        );
    }
}

impl SseEncode for crate::api::models::front_matter::front_matter_entity::FrontMatterEntity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.summary, serializer);
        <i32>::sse_encode(self.mdx_note_id, serializer);
        <Option<String>>::sse_encode(self.user_provided_id, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::models::enums::setting_page_ids::KeymapSectionId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::models::enums::setting_page_ids::KeymapSectionId::Navigation => 0,
                crate::api::models::enums::setting_page_ids::KeymapSectionId::UiAndLayout => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<BibEntryEntity> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <BibEntryEntity>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FlusterError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FlusterError>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<MdxNoteSummary> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <MdxNoteSummary>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::models::taggable::tag_model::TagCreatable> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::models::taggable::tag_model::TagCreatable>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::models::taggable::taggable::Taggable> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::models::taggable::taggable::Taggable>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::models::params::sync_mdx_typescript_params::MathLabelOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::Ams => 0,
                crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::All => 1,
                crate::api::models::params::sync_mdx_typescript_params::MathLabelOption::None => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.id, serializer);
        <Option<String>>::sse_encode(self.file_path, serializer);
        <String>::sse_encode(self.raw_body, serializer);
        <Option<chrono::NaiveDateTime>>::sse_encode(self.ctime, serializer);
        <Option<chrono::NaiveDateTime>>::sse_encode(self.mtime, serializer);
        <Option<chrono::NaiveDateTime>>::sse_encode(self.atime, serializer);
    }
}

impl SseEncode for crate::api::models::mdx_note::mdx_note_group::mdx_note_group::MdxNoteGroup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::models::mdx_note::mdx_note_creatable::MdxNoteCreatable>::sse_encode(
            self.mdx, serializer,
        );
        <crate::api::models::front_matter::front_matter_model::FrontMatter>::sse_encode(
            self.front_matter,
            serializer,
        );
        <Vec<crate::api::models::taggable::taggable::Taggable>>::sse_encode(self.tags, serializer);
    }
}

impl SseEncode for crate::api::models::enums::parsable_file_extension::NoteType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::models::enums::parsable_file_extension::NoteType::Mdx => 0,
                crate::api::models::enums::parsable_file_extension::NoteType::Markdown => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<EmbeddedFile> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <EmbeddedFile>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<PathBuf> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <PathBuf>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Pod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Pod>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<chrono::NaiveDateTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <chrono::NaiveDateTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<FlusterError>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<FlusterError>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::models::settings::setting_page_id::SettingPageId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::api::models::settings::setting_page_id::SettingPageId::General => { 0 }
crate::api::models::settings::setting_page_id::SettingPageId::WebInterface => { 1 }
crate::api::models::settings::setting_page_id::SettingPageId::Ui => { 2 }
crate::api::models::settings::setting_page_id::SettingPageId::KeyMap => { 3 }
crate::api::models::settings::setting_page_id::SettingPageId::Ai => { 4 }
crate::api::models::settings::setting_page_id::SettingPageId::SearchAndAutoSettings => { 5 }
crate::api::models::settings::setting_page_id::SettingPageId::SyncAndDatabase => { 6 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode
    for crate::api::global_actions::get_summary_list::summary_list_query::SummaryListQuery
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.mdx_per_page, serializer);
        <u16>::sse_encode(self.mdx_page, serializer);
    }
}

impl SseEncode
    for crate::api::global_actions::get_summary_list::summary_list_result::SummaryListResults
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<MdxNoteSummary>>::sse_encode(self.mdx_notes, serializer);
    }
}

impl SseEncode for crate::api::models::enums::supported_language::SupportedSyntaxLanguage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Abap => { 0 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Actionscript3 => { 1 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ada => { 2 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::AngularHtml => { 3 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::AngularTs => { 4 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Apache => { 5 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Apex => { 6 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Apl => { 7 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Applescript => { 8 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ara => { 9 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Asciidoc => { 10 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Asm => { 11 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Astro => { 12 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Awk => { 13 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ballerina => { 14 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bat => { 15 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Beancount => { 16 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Berry => { 17 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bibtex => { 18 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bicep => { 19 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Blade => { 20 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bsl => { 21 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::C => { 22 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cadence => { 23 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cairo => { 24 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Clarity => { 25 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Clojure => { 26 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cmake => { 27 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cobol => { 28 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Codeowners => { 29 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Codeql => { 30 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Coffee => { 31 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::CommonLisp => { 32 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Coq => { 33 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cpp => { 34 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Crystal => { 35 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Csharp => { 36 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Css => { 37 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Csv => { 38 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cue => { 39 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cypher => { 40 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::D => { 41 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dart => { 42 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dax => { 43 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Desktop => { 44 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Diff => { 45 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Docker => { 46 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dotenv => { 47 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::DreamMaker => { 48 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Edge => { 49 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Elixir => { 50 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Elm => { 51 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::EmacsLisp => { 52 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Erb => { 53 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Erlang => { 54 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fennel => { 55 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fish => { 56 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fluent => { 57 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::FortranFixedForm => { 58 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::FortranFreeForm => { 59 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fsharp => { 60 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gdresource => { 61 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gdscript => { 62 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gdshader => { 63 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Genie => { 64 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gherkin => { 65 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GitCommit => { 66 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GitRebase => { 67 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gleam => { 68 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GlimmerJs => { 69 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::GlimmerTs => { 70 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Glsl => { 71 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gnuplot => { 72 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Go => { 73 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Graphql => { 74 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Groovy => { 75 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hack => { 76 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Haml => { 77 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Handlebars => { 78 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Haskell => { 79 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Haxe => { 80 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hcl => { 81 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hjson => { 82 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hlsl => { 83 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Html => { 84 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::HtmlDerivative => { 85 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Http => { 86 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hxml => { 87 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hy => { 88 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Imba => { 89 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ini => { 90 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Java => { 91 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Javascript => { 92 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jinja => { 93 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jison => { 94 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Json => { 95 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Json5 => { 96 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsonc => { 97 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsonl => { 98 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsonnet => { 99 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jssm => { 100 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jsx => { 101 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Julia => { 102 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kotlin => { 103 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kusto => { 104 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Latex => { 105 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lean => { 106 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Less => { 107 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Liquid => { 108 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Llvm => { 109 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Log => { 110 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Logo => { 111 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lua => { 112 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Luau => { 113 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Make => { 114 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Markdown => { 115 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Marko => { 116 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Matlab => { 117 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mdc => { 118 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mdx => { 119 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mermaid => { 120 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mipsasm => { 121 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mojo => { 122 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Move => { 123 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Narrat => { 124 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nextflow => { 125 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nginx => { 126 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nim => { 127 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nix => { 128 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nushell => { 129 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::ObjectiveC => { 130 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::ObjectiveCpp => { 131 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ocaml => { 132 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Pascal => { 133 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Perl => { 134 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Php => { 135 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Plsql => { 136 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Po => { 137 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Polar => { 138 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Postcss => { 139 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Powerquery => { 140 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Powershell => { 141 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Prisma => { 142 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Prolog => { 143 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Proto => { 144 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Pug => { 145 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Puppet => { 146 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Purescript => { 147 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Python => { 148 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Qml => { 149 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Qmldir => { 150 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Qss => { 151 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::R => { 152 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Racket => { 153 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Raku => { 154 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Razor => { 155 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Reg => { 156 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Regexp => { 157 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rel => { 158 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Riscv => { 159 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rst => { 160 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ruby => { 161 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rust => { 162 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sas => { 163 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sass => { 164 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Scala => { 165 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Scheme => { 166 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Scss => { 167 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sdbl => { 168 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shaderlab => { 169 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shellscript => { 170 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shellsession => { 171 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Smalltalk => { 172 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Solidity => { 173 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Soy => { 174 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sparql => { 175 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Splunk => { 176 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sql => { 177 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::SshConfig => { 178 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Stata => { 179 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Stylus => { 180 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Svelte => { 181 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Swift => { 182 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::SystemVerilog => { 183 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Systemd => { 184 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Talonscript => { 185 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tasl => { 186 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tcl => { 187 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Templ => { 188 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Terraform => { 189 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tex => { 190 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Toml => { 191 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::TsTags => { 192 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tsv => { 193 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tsx => { 194 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Turtle => { 195 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Twig => { 196 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typescript => { 197 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typespec => { 198 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typst => { 199 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::V => { 200 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vala => { 201 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vb => { 202 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Verilog => { 203 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vhdl => { 204 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Viml => { 205 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vue => { 206 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::VueHtml => { 207 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vyper => { 208 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wasm => { 209 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wenyan => { 210 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wgsl => { 211 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wikitext => { 212 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wit => { 213 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wolfram => { 214 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Xml => { 215 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Xsl => { 216 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Yaml => { 217 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Zenscript => { 218 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Zig => { 219 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Adoc => { 220 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Batch => { 221 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Be => { 222 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::OneC => { 223 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cdc => { 224 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Clj => { 225 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ql => { 226 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Coffeescript => { 227 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lisp => { 228 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::CPlusPlus => { 229 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::CSharp => { 230 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cs => { 231 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cql => { 232 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Dockerfile => { 233 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Elisp => { 234 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Erl => { 235 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ftl => { 236 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F => { 237 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::For => { 238 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F77 => { 239 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F90 => { 240 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F95 => { 241 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F03 => { 242 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F08 => { 243 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::F18 => { 244 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::FSharp => { 245 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fs => { 246 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gjs => { 247 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gts => { 248 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Gql => { 249 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hbs => { 250 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Hs => { 251 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Properties => { 252 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Js => { 253 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Fsl => { 254 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jl => { 255 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kt => { 256 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kts => { 257 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Kql => { 258 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lean4 => { 259 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Makefile => { 260 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Md => { 261 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mmd => { 262 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mips => { 263 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nar => { 264 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nf => { 265 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Nu => { 266 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Objc => { 267 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Pot => { 268 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Potx => { 269 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ps => { 270 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ps1 => { 271 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Protobuf => { 272 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Jade => { 273 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Py => { 274 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Perl6 => { 275 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Regex => { 276 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rb => { 277 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Rs => { 278 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::OneCQuery => { 279 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shader => { 280 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Bash => { 281 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Sh => { 282 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Shell => { 283 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Zsh => { 284 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Console => { 285 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::ClosureTemplates => { 286 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Spl => { 287 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Styl => { 288 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Talon => { 289 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tf => { 290 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tfvars => { 291 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Lit => { 292 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Ts => { 293 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Tsp => { 294 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Typ => { 295 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Cmd => { 296 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vim => { 297 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vimscript => { 298 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Vy => { 299 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Mediawiki => { 300 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wiki => { 301 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Wl => { 302 }
crate::api::models::enums::supported_language::SupportedSyntaxLanguage::Yml => { 303 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::global_actions::parse_directory::sync_fs_directory::models::sync_filesystem_options::SyncFilesystemDirectoryOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<String>::sse_encode(self.dir_path, serializer);
<Option<String>>::sse_encode(self.bib_path, serializer);
<u32>::sse_encode(self.n_threads, serializer);}
                }

impl SseEncode for crate::api::models::taggable::tag_model::TagCreatable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.tag_type, serializer);
    }
}

impl SseEncode for crate::api::models::taggable::taggable::TagFromContentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::models::taggable::taggable::Taggable>>::sse_encode(self.tags, serializer);
        <String>::sse_encode(self.parsed_content, serializer);
    }
}

impl SseEncode for crate::api::models::taggable::taggable::Taggable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <crate::api::models::enums::taggable_type::TaggableTypeEnum>::sse_encode(
            self.tag_type,
            serializer,
        );
    }
}

impl SseEncode for crate::api::models::enums::taggable_type::TaggableTypeEnum {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::models::enums::taggable_type::TaggableTypeEnum::Tag => 0,
                crate::api::models::enums::taggable_type::TaggableTypeEnum::Topic => 1,
                crate::api::models::enums::taggable_type::TaggableTypeEnum::Subject => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use crate::api::global_actions::parse_directory::sync_fs_directory::sync_methods::sync_mdx_notes::*;
use crate::api::models::bibliography::bib_entry::*;
use crate::api::models::bibliography::bib_file::*;
use crate::api::embedded_ts::*;
use crate::api::models::mdx_note::mdx_note_group::mdx_note_group::*;
use crate::api::actions::mdx_note::get_many::*;
use crate::api::models::taggable::taggable::*;
use crate::api::data_interface::database::utils::*;
use crate::api::models::front_matter::front_matter_model::*;
use crate::api::actions::front_matter::get_many::*;
use crate::api::models::mdx_note::mdx_note_summary::*;use flutter_rust_bridge::{Handler, IntoIntoDart};
use flutter_rust_bridge::for_generated::{Lockable, transform_result_dco, Lifetimeable};
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, WriteBytesExt, ReadBytesExt};use super::*;

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBibEntryEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBibEntryEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< EmbeddedFile>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< EmbeddedFile>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedTypescriptFiles(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedTypescriptFiles(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterDb(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterDb(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultMdxNoteGroup(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
        >::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultMdxNoteGroup(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
        >::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecFrontMatterEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<FrontMatterEntity>>,
            >,
        >::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecFrontMatterEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<FrontMatterEntity>>,
            >,
        >::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecMdxNoteEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<MdxNoteEntity>>,
            >,
        >::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecMdxNoteEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<MdxNoteEntity>>,
            >,
        >::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMdxNoteSummary(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMdxNoteSummary(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParsedEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParsedEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPod(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPod(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRegex(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRegex(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < FlusterError >>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fluster_native_interface_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < FlusterError >>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use crate::api::global_actions::parse_directory::sync_fs_directory::sync_methods::sync_mdx_notes::*;
use crate::api::models::bibliography::bib_entry::*;
use crate::api::models::bibliography::bib_file::*;
use crate::api::embedded_ts::*;
use crate::api::models::mdx_note::mdx_note_group::mdx_note_group::*;
use crate::api::actions::mdx_note::get_many::*;
use crate::api::models::taggable::taggable::*;
use crate::api::data_interface::database::utils::*;
use crate::api::models::front_matter::front_matter_model::*;
use crate::api::actions::front_matter::get_many::*;
use crate::api::models::mdx_note::mdx_note_summary::*;use flutter_rust_bridge::{Handler, IntoIntoDart};
use flutter_rust_bridge::for_generated::{Lockable, transform_result_dco, Lifetimeable};
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, WriteBytesExt, ReadBytesExt};use super::*;
                use flutter_rust_bridge::for_generated::wasm_bindgen;
                use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBibEntryEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBibEntryEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BibEntryEntity>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< EmbeddedFile>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< EmbeddedFile>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedTypescriptFiles(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmbeddedTypescriptFiles(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmbeddedTypescriptFiles>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterDb(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterDb(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterDb>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterError>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultMdxNoteGroup(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
        >::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultMdxNoteGroup(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FlusterResult<MdxNoteGroup>>,
        >::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecFrontMatterEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<FrontMatterEntity>>,
            >,
        >::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecFrontMatterEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<FrontMatterEntity>>,
            >,
        >::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecMdxNoteEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<MdxNoteEntity>>,
            >,
        >::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlusterResultVecMdxNoteEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                FlusterResult<Vec<MdxNoteEntity>>,
            >,
        >::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMdxNoteSummary(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMdxNoteSummary(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdxNoteSummary>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParsedEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParsedEntity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ParsedEntity>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPod(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPod(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pod>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRegex(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRegex(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Regex>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < FlusterError >>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderFlusterError(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < FlusterError >>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
